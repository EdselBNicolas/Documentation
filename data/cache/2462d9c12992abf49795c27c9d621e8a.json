{"html":"<!-- TITLE: Socket.IO --><!-- SUBTITLE:Socket.IO enables real-time, bidirectional and event-based communication --><html><head></head><body><h1 id=\"description\"><a class=\"toc-anchor nc-icon-outline location_bookmark-add internal-link\" href=\"#description\" aria-hidden=\"true\"></a> Description</h1>\n<p>This web socket implementation used both socket.io-client and ngrx/store.</p>\n<p><a href=\"http://socket.io\" class=\"external-link\">socket.io</a> documentation: <a href=\"https://socket.io/get-started/chat\" class=\"external-link\">https://socket.io/get-started/chat</a><br>\nngrx/store documentation: <a href=\"https://ngrx.io/guide/store\" class=\"external-link\">https://ngrx.io/guide/store</a></p>\n<h1 id=\"configuration\"><a class=\"toc-anchor nc-icon-outline location_bookmark-add internal-link\" href=\"#configuration\" aria-hidden=\"true\"></a> Configuration</h1>\n<p>Our file structure:</p>\n<p>&#x1F4C1; src<br>\nI--&#x1F4C1; providers<br>\nI-----------I--&#x1F4C1; websocket<br>\nI----------------------I--&#x1F4C4; events.ts<br>\nI----------------------I--&#x1F4C4; index.ts<br>\nI--&#x1F4C1; store<br>\nI--------I--&#x1F4C1;websocket<br>\nI-------------------I--&#x1F4C1;reducers<br>\nI----------------------------I--&#x1F4C4;resetStates.ts<br>\nI-------------------I--&#x1F4C4;index.ts</p>\n<p>Before adding a socket connection, we should first add the following:</p>\n<ol>\n<li>Websocket<br>\n* Events</li>\n<li>ngrx/store<br>\n* Reducers<br>\n* Actions</li>\n</ol>\n<p>First, in the <code>&#x1F4C4;events.ts,</code> our code will be:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> [\n    <span class=\"hljs-comment\">// add room name here</span>\n  ]\n}\n\n</code></pre>\n<p>We will export all the event/room names needed to call the data from the websocket<br>\nNote: Inside the array, only include string names</p>\n<p>Example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> [\n    <span class=\"hljs-string\">&apos;newMessage&apos;</span>\n  ]\n}\n\n</code></pre>\n<p>Next will be our reducers and actions inside the <code>&#x1F4C1;reducers</code> folder<br>\nExample:<br>\n1. Create a file inside the <code>&#x1F4C1;reducers</code> folder named <code>&#x1F4C4;newMessage.ts</code><br>\nNote: Use the event name for the file name to easily recognize the reducer<br>\n2. You can now add the code for reducer:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { Action } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&apos;@ngrx/store&apos;</span>;\n<span class=\"hljs-keyword\">const</span> NEW_MESSAGE = <span class=\"hljs-string\">&apos;[Websocket] New Message&apos;</span>;\n<span class=\"hljs-keyword\">type</span> Type = NewMessage\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> NewMessage <span class=\"hljs-keyword\">implements</span> Action{\n  readonly <span class=\"hljs-keyword\">type</span> = NewMessage\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> payload: <span class=\"hljs-built_in\">any</span></span>){}\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">newMessageReducer</span>(<span class=\"hljs-params\">state: <span class=\"hljs-built_in\">any</span>, action: Type</span>)</span>{\n  <span class=\"hljs-keyword\">switch</span> (action.type) {\n      <span class=\"hljs-keyword\">case</span> NEW_MESSAGE:\n      <span class=\"hljs-keyword\">return</span> action.payload;\n  }\n}\n\n</code></pre>\n<pre><code>3. Keep in mind that every socket room needs a reducer file.\n</code></pre>\n<p>Our new file structure will be like this:<br>\n&#x1F4C1; src<br>\nI--&#x1F4C1; providers<br>\nI-----------I--&#x1F4C1; websocket<br>\nI----------------------I--&#x1F4C4; events.ts<br>\nI----------------------I--&#x1F4C4; index.ts<br>\nI--&#x1F4C1; store<br>\nI--------I--&#x1F4C1;websocket<br>\nI-------------------I--&#x1F4C1;reducers<br>\nI----------------------------I--&#x1F4C4;resetStates.ts<br>\nI----------------------------I--&#x1F4C4;newMessage.ts  &lt;= newly added reducer<br>\nI----------------------------I--&#x1F4C4;index.ts</p>\n<p>We will register our reducers in <code>&#x1F4C4;index.ts</code> file inside <code>&#x1F4C1;reducers</code> folder:<br>\nI--&#x1F4C1; store<br>\nI--------I--&#x1F4C1;websocket<br>\nI-------------------I--&#x1F4C1;reducers<br>\nI----------------------------I--&#x1F4C4;resetStates.ts<br>\nI----------------------------I--&#x1F4C4;index.ts        &lt;= we will register it here</p>\n<p>and our code will be:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// class and reducer imports here~</span>\n<span class=\"hljs-keyword\">import</span> { newMessage, newMesssageReducer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&apos;./reducers/currentOrderLocation&apos;</span>;\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> reducers = {\n  <span class=\"hljs-comment\">// add reducers here~</span>\n  newMessage: newMessageReducer,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> actions = {\n  <span class=\"hljs-comment\">// add action class here~</span>\n  newMessage: newMessage,\n}\n\n<span class=\"hljs-comment\">// For reseting all states</span>\n<span class=\"hljs-keyword\">import</span> { ResetStates, ResetStatesReducer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&apos;./reducers/resetStates&apos;</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> resetStatesReducer = [ResetStatesReducer]\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> resetStates = ResetStates\n</code></pre>\n<p>Note: The reset states, will reset all data from the store to <code>undefined</code><br>\nWe can achieve this by simply calling <code>this.store.dispatch(new resetStates())</code></p>\n<p>Finally, we can now make our socket connection in-<br>\nI--&#x1F4C1; providers<br>\nI--------I--&#x1F4C1; websocket<br>\nI--------------------I--&#x1F4C4; index.ts   &lt;= We will add the socket connection in this file</p>\n<p>our connection code will look like this:</p>\n<pre class=\"hljs\"><code>connect(token, callback) {\n    <span class=\"hljs-keyword\">const</span> delay = <span class=\"hljs-keyword\">this</span>.close() ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1000</span>\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">this</span>.socket = io(GlobalsProvider.websocketUrl, {\n        reconnect: <span class=\"hljs-literal\">true</span>,\n        transports: [<span class=\"hljs-string\">&apos;websocket&apos;</span>],\n        query: {\n          token: token\n        }\n      })\n\n      <span class=\"hljs-keyword\">const</span> actionList = actions\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> event of Events()) {\n        <span class=\"hljs-keyword\">this</span>.socket.on(event, <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n          <span class=\"hljs-keyword\">this</span>.store.dispatch(<span class=\"hljs-keyword\">new</span> actionList[event](data));\n        })\n      }\n    }, delay)\n}\n</code></pre>\n<p>We will also add three(3) functions needed for socket communication:</p>\n<pre class=\"hljs\"><code>  on(name) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.store.select(name)\n  }\n\n  emit(event, payload) {\n    <span class=\"hljs-keyword\">try</span> { <span class=\"hljs-keyword\">this</span>.socket.emit(event, payload) }\n    <span class=\"hljs-keyword\">catch</span> (error) { }\n  }\n\n  close() {\n    <span class=\"hljs-keyword\">try</span> { <span class=\"hljs-keyword\">this</span>.socket.close() }\n    <span class=\"hljs-keyword\">catch</span> (error) { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span> }\n  }\n</code></pre>\n<p>The <code>on()</code> function will be our substitute for the <code>io.on()</code> function in the <a href=\"http://socket.io\" class=\"external-link\">socket.io</a><br>\ndocumentation. In this process we will get the data from the ngrx/store using <code>this.store.select(name)</code>.<br>\nIt accepts the event name and will return an observable that will also updated everytime the socket received the data.</p>\n<p>It will be updated like the traditional <a href=\"http://socket.io\" class=\"external-link\">socket.io</a> subscription because of this code:</p>\n<pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">this</span>.socket.on(event, <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n         <span class=\"hljs-keyword\">this</span>.store.dispatch(<span class=\"hljs-keyword\">new</span> actionList[event](data));\n  })\n</code></pre>\n<p>We already subscribed ALL the socket connections that we have and already available since we run the app.</p>\n<p>The <code>emit()</code> function and <code>io.emit()</code> is the same, the only difference is the error handling in the defined function</p>\n<p>The <code>close()</code> function is used after the logout or any event that we dont need the socket anymore<br>\nNote: Calling this function will close the current socket connection and will never reconnected again unless<br>\nthe <code>connect()</code> function is called again.</p>\n<h1 id=\"usage\"><a class=\"toc-anchor nc-icon-outline location_bookmark-add internal-link\" href=\"#usage\" aria-hidden=\"true\"></a> Usage</h1>\n<p>We will first add the WebsocketProvider in the &#x1F4C4;app.module.ts file</p>\n<p>Then, will call the <code>connect()</code> function in two conditions:</p>\n<ol>\n<li>The app should have the token in the storage and</li>\n<li>We need to call it from the start when the app is already loaded</li>\n</ol>\n<p>Example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">async</span> socketConnect() {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.storage.get(<span class=\"hljs-string\">&apos;token&apos;</span>)\n  <span class=\"hljs-keyword\">this</span>.socket.connect(token, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;socket connected!&apos;</span>);\n  })\n}\n</code></pre>\n<p>The <code>connect()</code> function will establish connection between the server and the client.</p>\n<p>It will also create a storage for every socket event/room that will process here:</p>\n<pre class=\"hljs\"><code>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> event of Events()) {\n        <span class=\"hljs-keyword\">this</span>.socket.on(event, <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n          <span class=\"hljs-keyword\">this</span>.store.dispatch(<span class=\"hljs-keyword\">new</span> actionList[event](data));\n        })\n  }\n</code></pre>\n<p>and after we dispatch, we can now subscribe to our socket connections in any page.</p>\n<p>We need to add the provider (WebsocketProvider) in our pages so that we can achieve something like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">this</span>.ws.on(<span class=\"hljs-string\">&apos;newMessage&apos;</span>).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">newMessage</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// do something with newMessage data</span>\n})\n</code></pre>\n<p>Note: If you subscribe from a pushed page, please wrapped it in subscription to unsubscribe on page pop/dismiss</p>\n<ul>\n<li>You can check the subscription documentation here: <a href=\"http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html\" class=\"external-link\">http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html</a><br>\nExample:</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { ISubscription } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;rxjs/Subscription&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span><span class=\"hljs-string\">``</span><span class=\"hljs-string\">``</span><span class=\"hljs-string\">``</span> <span class=\"hljs-keyword\">implements</span> OnDestroy {\n\n<span class=\"hljs-keyword\">private</span> subscription = []\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> subscription: ISubscription</span>) {\n\n    <span class=\"hljs-keyword\">this</span>.subscription.push(<span class=\"hljs-keyword\">this</span>.ws.on(<span class=\"hljs-string\">&apos;newMessage&apos;</span>).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">newMessage</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// do something with newMessage data</span>\n    }))\n  \n  }\n  \n  ngOnDestroy() {\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> s of subscription) {\n      s.unsubscribe()\n    }\n  }\n\n}\n\n</code></pre>\n<p>Unable to unsubscribe creates multiple subscription and will run the code inside the subscribe block<br>\nmultiple times.</p>\n<p>If you want to know more about ngrx/store (reducers, actions, process, etc) you can learn here:<br>\n<a href=\"https://medium.com/frontend-fun/angular-ngrx-a-clean-and-clear-introduction-4ed61c89c1fc\" class=\"external-link\">https://medium.com/frontend-fun/angular-ngrx-a-clean-and-clear-introduction-4ed61c89c1fc</a></p>\n</body></html>","meta":{"title":"Socket.IO","subtitle":"Socket.IO enables real-time, bidirectional and event-based communication","path":"providers/socket-io"},"tree":[{"content":"Description","anchor":"description","nodes":[]},{"content":"Configuration","anchor":"configuration","nodes":[]},{"content":"Usage","anchor":"usage","nodes":[]}],"parent":{"path":"providers","title":"Providers","subtitle":"A quick summary of Providers"}}